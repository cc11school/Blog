<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>test</title>
    <url>/2023/10/04/test/</url>
    <content><![CDATA[<p><span class="math display">\[a b c\]</span></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>CF1767C题解</title>
    <url>/2023/10/03/CF1767C%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="cf1767c-count-binary-strings-题解">CF1767C Count Binary Strings
题解</h1>
<h2 id="foreword">Foreword</h2>
<p>感谢 <a href="https://www.luogu.com.cn/user/234074"><span
class="citation" data-cites="樱雪喵">@樱雪喵</span></a>、<a
href="https://www.luogu.com.cn/user/183154"><span class="citation"
data-cites="swiftc">@swiftc</span></a> 两位大佬的耐心指导。</p>
<h2 id="links">Links</h2>
<p><a href="https://www.luogu.com.cn/problem/CF1767C">洛谷</a></p>
<p><a
href="https://codeforces.com/problemset/problem/1767/C">Codeforces</a></p>
<h2 id="description">Description</h2>
<p>有一个长度为 <span class="math inline">\(n\)</span> 的 01 串 <span
class="math inline">\(s\)</span>（下标从 <span
class="math inline">\(1\)</span> 开始）和一些限制 <span
class="math inline">\(a_{i,j}(1 \le i \le j \le n)\)</span>。</p>
<p><span class="math inline">\(a_{i,j}\)</span> 的含义如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span
class="math inline">\(a_{i,j}=\)</span></th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(0\)</span></td>
<td style="text-align: center;">没有限制</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(1\)</span></td>
<td style="text-align: center;">对于所有的 <span class="math inline">\(i
\le p \le q \le j\)</span> 均有 <span
class="math inline">\(s_p=s_q\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(2\)</span></td>
<td style="text-align: center;">存在 <span class="math inline">\(i \le p
\le q \le j\)</span> 使得 <span class="math inline">\(s_p \neq
s_q\)</span></td>
</tr>
</tbody>
</table>
<p>求可能的 <span class="math inline">\(s\)</span>
的个数。<strong>答案对 <span class="math inline">\(998244353\)</span>
取模。</strong></p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据，<span
class="math inline">\(2 \le n \le 100\)</span>，<span
class="math inline">\(0 \le a_{i,j} \le 2\)</span>。</p>
<h2 id="solution">Solution</h2>
<p>这种计数类问题大概率是组合数学或者
dp，然而这道题限制条件很多，组合数学大概是做不成了，那么考虑 dp。</p>
<p>首先一个很显然的情况是如果 <span class="math inline">\(a_{i,i} =
2\)</span> 那么无解。接下来考虑对 <span class="math inline">\(a_{i,j} =
1\)</span>
的限制，我们把这些需要区间内全相同的合并成一个块，对块内每个位置的限制等价于对整个块的限制，使用并查集维护即可，注意每个块合并的时候都合并到最前面的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fa[<span class="number">222</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[u] == u)</span><br><span class="line">        <span class="keyword">return</span> fa[u];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> fa[u] = <span class="built_in">find</span>(fa[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(u) == <span class="built_in">find</span>(v))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(u) &lt; <span class="built_in">find</span>(v))</span><br><span class="line">        fa[<span class="built_in">find</span>(v)] = <span class="built_in">find</span>(u);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fa[<span class="built_in">find</span>(u)] = <span class="built_in">find</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主函数中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(nums[i][j]);</span><br><span class="line">        <span class="keyword">if</span> (nums[i][j] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt;= j; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">merge</span>(i, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后，我们很容易想到，对于每个块 <span
class="math inline">\(p\)</span>，我们找到对于 <span
class="math inline">\(i \in p\)</span>，<span
class="math inline">\(a_{i,j} = 2\)</span> 这样的限制中最大的 <span
class="math inline">\(j\)</span>，只要满足这条限制，在前面的限制也就都满足了，求出
<span class="math inline">\(mx_{i}\)</span> 表示块 <span
class="math inline">\(i\)</span> 之前最后一个能满足从 <span
class="math inline">\(mx_{i}\)</span> 到 <span
class="math inline">\(i\)</span> 与 <span
class="math inline">\(i\)</span> 填的数全相同的块。</p>
<p>DP
的思路有两种，一种是一维的，另一种是二维的。我开始写的一维，然而没有考虑到一些问题写挂了，尝试了二维通过之后又回到了一维。</p>
<p>这里先从二维 DP 开始讲。</p>
<p>考虑某个位置和前一位是否相同，有：</p>
<p><span class="math display">\[\begin{cases}
dp_{i,j} = dp_{i - 1,j} &amp; \texttt{if } s_{i} = s_{i - 1}
\\
dp_{i,i} = \sum_{j = mx_{i}}^{i - 1} dp_{i - 1,j} &amp; \texttt{if }
s_{i} \neq s_{i - 1}
\end{cases}\]</span></p>
<p>即如果要求和前一位相同，不会有新的贡献，否则累加贡献。</p>
<p>直接判断是否可行并转移即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i) == i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            (dp[i][i] += dp[i - <span class="number">1</span>][j]) %= <span class="number">998244353</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = mx[<span class="built_in">find</span>(i)]; j &lt; i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        (dp[i][j] += dp[i - <span class="number">1</span>][j]) %= <span class="number">998244353</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = mmx; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    (res += dp[n][i]) %= <span class="number">998244353</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">writeln</span>(<span class="number">2</span> * res % <span class="number">998244353</span>);</span><br></pre></td></tr></table></figure>
<p>接下来考虑一维 DP 怎么做。</p>
<p><span class="math display">\[\begin{cases}
dp_{i,j} = dp_{i - 1,j} &amp; \texttt{if } s_{i} = s_{i - 1}
\\
dp_{i,i} = \sum_{j = mx_{i}}^{i - 1} dp_{i - 1,j} &amp; \texttt{if }
s_{i} \neq s_{i - 1}
\end{cases}\]</span></p>
<p>上面的方程实际上就是 相同的地方 复制了 前面第一个不同的地方 /kk</p>
<p>定义 <span class="math inline">\(k\)</span> 为 <span
class="math inline">\(i\)</span> 之前第一个不同的。有 <span
class="math display">\[
dp_{i,i} = \sum_{k}\sum_{j = mx_{i}}^{i - 1} dp_{k,j} \ \texttt{  if }
s_{i} \neq s_{i - 1}
\]</span></p>
<p>也就是我们每次从 <span class="math inline">\(k\)</span>
转移并且累加一下。</p>
<p>注意到由于 <span class="math inline">\(s_{k} \neq s_{k -
1}\)</span>，我们之前计算 <span
class="math inline">\(dp_{k,j&#39;}\)</span> 的时候应该只更新了 <span
class="math inline">\(dp_{k,k}\)</span>。</p>
<p>因此实际上我们得到的是 <span class="math inline">\(dp_{i,i} =
\sum_{k}dp_{k,k} \ \texttt{ if } mx_{i} \leq k \leq i - 1\)</span>。</p>
<p>优化掉第二维，有 $dp_{i} = <em>{k = mx</em>{i}}^{i - 1}dp_{k} $。</p>
<p><strong>注意：这里有个问题，假设有按顺序 <span
class="math inline">\(A,B,C,D\)</span> 四个块，如果限制 <span
class="math inline">\(B,C\)</span> 不能相同，那么显然我们无法从 <span
class="math inline">\(A\)</span> 到 <span
class="math inline">\(D\)</span> 全部相同，因此我们 <span
class="math inline">\(mx\)</span> 还要取一个前缀 <span
class="math inline">\(\operatorname{max}\)</span></strong>。</p>
<p>由于我们合并块的编号并不连续，这不利于我们
dp，因此将块的编号离散化一下即可。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于 fa 更新的时候不是 1,2,3,4 这样，而是每块第一个的编号</span></span><br><span class="line"><span class="comment">// 我们把 fa[i] 离散化，pos 表示是第几个，rea 表示第 i 个的实际 fa</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i) == i)</span><br><span class="line">    &#123;</span><br><span class="line">        rea[++rea[<span class="number">0</span>]] = i;</span><br><span class="line">        pos[i] = rea[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
之后枚举上一个不同的点转移就可以了，方程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i) != i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++cnt;</span><br><span class="line">    <span class="comment">// 现在只有无限制和要求出现不同了</span></span><br><span class="line">    <span class="comment">// 我们可以枚举上一个不同的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = pos[mx[rea[cnt]]]; j &lt; cnt; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        (dp[cnt] += dp[j]) %= <span class="number">998244353</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把所有 <span class="math inline">\(0\)</span>，<span
class="math inline">\(1\)</span> 交换不会违反限制，因此答案要乘 <span
class="math inline">\(2\)</span>。</p>
<h2 id="codes">Codes</h2>
<p>一维完整代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Problem: C. Count Binary Strings</span></span><br><span class="line"><span class="comment">// Contest: Educational Codeforces Round 140 (Rated for Div. 2)</span></span><br><span class="line"><span class="comment">// URL: https://codeforces.com/contest/1767/problem/C</span></span><br><span class="line"><span class="comment">// Memory Limit: 512 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 2000 ms</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            k = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    p *= k;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">write_</span>(x / <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writesp</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">write_</span>(x);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeln</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">write_</span>(x);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, nums[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line"><span class="type">int</span> fa[<span class="number">222</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[u] == u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> fa[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> fa[u] = <span class="built_in">find</span>(fa[u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(u) == <span class="built_in">find</span>(v))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(u) &lt; <span class="built_in">find</span>(v))</span><br><span class="line">    &#123;</span><br><span class="line">        fa[<span class="built_in">find</span>(v)] = <span class="built_in">find</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        fa[<span class="built_in">find</span>(u)] = <span class="built_in">find</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">222</span>];</span><br><span class="line"><span class="type">int</span> mx[<span class="number">222</span>];</span><br><span class="line"><span class="type">int</span> rea[<span class="number">222</span>];</span><br><span class="line"><span class="type">int</span> pos[<span class="number">222</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">read</span>(nums[i][j]);</span><br><span class="line">            <span class="keyword">if</span> (nums[i][j] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt;= j; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">merge</span>(i, k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i][i] == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于每一个需要找到最晚需要不同的，这样能满足前面的所有条件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mx[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j][i] == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">find</span>(i) == <span class="built_in">find</span>(j))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                mx[<span class="built_in">find</span>(i)] = <span class="built_in">max</span>(mx[<span class="built_in">find</span>(i)], <span class="built_in">find</span>(j));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mx[i] = <span class="built_in">max</span>(mx[i], mx[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i) == i)</span><br><span class="line">        &#123;</span><br><span class="line">            rea[++rea[<span class="number">0</span>]] = i;</span><br><span class="line">            pos[i] = rea[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i) != i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="comment">// 现在只有无限制和要求出现不同了</span></span><br><span class="line">        <span class="comment">// 我们可以枚举上一个不同的位置</span></span><br><span class="line">        <span class="comment">// 由于 fa 更新的时候不是 1,2,3,4 这样，而是每块第一个的编号</span></span><br><span class="line">        <span class="comment">// 我们把 fa[i] 离散化，pos 表示是第几个，rea 表示第 i 个的实际 fa</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = pos[mx[rea[cnt]]]; j &lt; cnt; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            (dp[cnt] += dp[j]) %= <span class="number">998244353</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//   cout &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">writeln</span>(<span class="number">2</span> * dp[cnt] % <span class="number">998244353</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
</search>
